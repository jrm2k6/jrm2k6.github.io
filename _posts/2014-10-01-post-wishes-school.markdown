---
layout: post
title: Studies
---

##Introduction ##

I have attended two different universities in France. I got my bachelor degree in Computer Science in a tiny university close to my hometown. Then, I moved to a bigger city to study in an engineering school, and graduate in "Computer Science: Software and Networks".
I also spent two semesters at Laval University, in French-Canada, which was a really great experience.

After two years working as a software engineer, there are a lot of things I wish I had learned at school.

#####Note: I have also done an internship in a UC university where I have seen how different studies were in the US, so this applies only to French/European schools to a certain extent. #####

## Testing ##

This is crazy to see that testing was such a tiny portion of my studies, when it is probably the only way to ensure your implementation is correct, and that you are not going backwards when adding new features by also adding regressions. I remember that only unit testing was taught in a practical way. We had to use JUnit to prove some characteristics of triangle. I wish I would have been introduced to integration testing, mocking, code coverage and so on. Now I know that testing is a big part of how I work on projects. I always keep in mind that I should structure my code in a certain way if I want to be able to test it easily and efficiently. You can avoid messy code by thinking of your test implementation far ahead.

## Continuous integration ##
When I started working at Prezi, I was amazed at how we were deploying several times a day, and that you would know in around 10 minutes if you had messed something up in your codebase. I didn't know what Jenkins was, and was really unfamiliar with Agile methodology, Kanban and other buzzwords. I just remember learning about Waterfall at school, and that it was the only thing that you used in the real-world. Scrum was mentioned, but everything was always falling back to the Waterfall model.

## Version control system ##
I remember using subversion during my first and second internships, and asked to push code using git for some job interviews. I had to learn them on my own, and it was greatly beneficial to me. I still find it weird when I see new employees and fresh graduates getting surprised by the fact of using git or other VCS. I think it should be demonstrated at school that VCS are helping people to work together. It should also be shown how it is used for features development, branches, staging, releasing and so on. I remember being shocked when I had to work with computer science students, close to graduate, wanting to use dropbox and email to exchange the parts of their code they were working on. It was unbelievable that they were refusing to use git/SVN/you-name-it. To me, the way they were doing it was such a waste of time.

##Functional programming##
I had two ocaml courses. The first one still sounds pretty bad in my mind. It was unclear and not really practical.
The practical assignment was something related to creating our own language (it was so boring, I don't even remember it).
The second course was much better. The teacher made it sound less scary, explained how immutability was good and introduced streams. At the time, this really changed the way I was thinking about coding. I started to see states as being bad, and immutability as being error-safe. The assignments were also great. They were smaller exercises, or even little games.
Functional programing is important because it teaches you another way of thinking about your code.

##Less written exams, more practical projects ##
Ask us to create a game. Ask us to implement a web app. Don't try to trick us all the time with pointers in C, or crazy design-patterns use cases in Java or a stupid use of generics in C++. This creates a mis-representation of real-world problems that we might face. And don't do it on sheets of paper. Honestly, on paper..?
Put us in front of a terminal, ask us to pair-program and to push our code on git at the end of the session, with some nice unit tests. That will make us better engineers, able to know what problems we are really interested in. It will make us being productive much faster in our first company.

#####Note: I might be biased as I am not working in a startup, and don't know anything else. Whether you agree or think this is bullshit, reach out to me. I'd love to hear some thoughts.#####
